Association Mapping
===================

This chapter introduces association mappings. PHPCR has a tree based model of the content.
In addition to references to arbitrary other documents, every document has a parent and may
has children.

We will start with the hierarchy associations and then go into the references, which work
slightly different from what you are used from an RDBMS as well.

.. _hierarchy-mappings:

Hiearchy mappings
-----------------

We have already seen the ``ParentDocument`` in the previous chapter in the section about
identifier generation. The field with this annotation maps the parent document of this document
(PHPCR\NodeInterface::getParent()). If the repository can determine the document class of the
parent, it will use it, otherwise Doctrine\ODM\PHPCR\Document\Generic is used.

To map children, you have two options:

- You can map a single child with a specific name
- Or you can map a :ref:`collection <collections>` of children, with the possibility to filter on the document name

A single Child will always load only one document. If no explicit name is specified, the field
name is used to retrieve the child document. The name is the last part of that documents id,
resp. its Nodename mapping.

To map a collection of children, use ``Children``. This will always be a collection, regardless of
the number of found children. You can limit the children to a subset of all children by specifying
a ``filter`` that acts on the node name. See `PHPCR\NodeInterface::getNodes() <http://phpcr.github.com/doc/html/phpcr/nodeinterface.html#getNodes()>`_
for details on allowed filters.

To tweak performance, you can also specify a ``fetchDepth`` if you know that you will always access children
of the mapped children. This can improve performance when you need to load a more complicated structure.
(See also :doc:`Tuning the node preloading <fetch-depth>`).

Some sample mappings:

.. configuration-block::

    .. code-block:: php

        <?php
        /** @Parentdocument */
        private $parent;
        /** @Child */
        private $mychild;
        /** @Children(filter="a*", fetchDepth=3) */
        private $children;

    .. code-block:: xml

        <doctrine-mapping>
          <document name="MyPersistentClass">
            <parentdocument name="parent" />
            <child fieldName="mychild" />
            <children fieldName="children" filter="a*" fetchDepth="3" />
          </document>
        </doctrine-mapping>

    .. code-block:: yaml

        MyPersistentClass:
          parentdocument: parent
          child:
            mychild: ~
          children:
            some:
             filter: "a*"
             fetchDepth: 3



References
----------

In PHPCR any referenceable node can be referenced by any other node, regardless of their types.

References are always directional, but thanks to the Referrers, you can model the back reference as well.

References use universally unique identifiers automatically generated on documents if they
are set to be referenceable. That way, a reference will stay intact even if documents are moved.
A field can reference one or many documents, and it can enforce referencial integrity or create
a weak reference that does not ensure integrity, depending on your use case.


.. _association-mapping_referenceable:

Referenceable documents
~~~~~~~~~~~~~~~~~~~~~~~

To be allowed to reference a document, it needs to be referenceable. To achieve this, the fact needs
to be specified in the Document mapping. Having a referenceable document also allows you to use the
map its uuid to a field.

The Uuid is read only, autogenerated on the first flush of the document. It follows the universially unique
id standard and is guaranteed to be unique for the whole PHPCR repository (all workspaces).


.. configuration-block::

    .. code-block:: php

        <?php
        /** @Document(referenceable=true) **/
        class MyPersistentClass
        {
            /**
             * @Uuid
             **/
            private $uuid;

        }

    .. code-block:: xml

        <doctrine-mapping>
            <document class="MyPersistentClass" referenceable="true">
                <uuid fieldName="uuid" />
            </document>
        </doctrine-mapping>

    .. code-block:: yaml

        MyPersistentClass:
          referenceable: true
          uuid: uuid

.. note::

    PHPCR-ODM has no migrations (yet). If you change a document class to become referenceable,
    you need to load and save every document of that type to make the stored documents note the change.


.. _associationmapping_referenceotherdocuments:

Reference other documents
~~~~~~~~~~~~~~~~~~~~~~~~~

As noted above, the target document needs to be referenceable. Apart from that, there is
no limitation on the type of the target document, giving you great flexibility.

There are two mappings, ReferenceOne and ReferenceMany to reference one or several
target documents. ReferenceMany is using doctrine commons collections.


You can specify for each reference if it should ensure referencial integrity or just
be a weak reference. By default, a weak reference is created, allowing you to delete
the referenced target document. Alternatively you can also tell PHPCR-ODM to reference by path,
which is interesting to create references to non-referenceable documents and when using relative paths.
A path reference will never ensure referential integrity.
(TODO: solve the open issue of how we can make paths relative and document here)

.. configuration-block::

    .. code-block:: php

        /** @ReferenceOne(strategy="weak") */
        private $weakTarget;
        /** @ReferenceOne(strategy="hard") */
        private $hardTarget;
        /** @ReferenceOne(strategy="path") */
        private $pathTarget;
        /** @ReferenceMany(strategy="weak") */
        private $weakGroup;
        /** @ReferenceMany(strategy="hard") */
        private $hardGroup;
        /** @ReferenceMany(strategy="path") */
        private $pathGroup;

    .. code-block:: xml

        <doctrine-mapping>
            <document class="MyPersistentClass">
                <reference-one fieldName="weakTarget" strategy="weak" />
                <reference-one fieldName="hardTarget" strategy="hard" />
                <reference-one fieldName="pathTarget" strategy="path" />
                <reference-many fieldName="weakGroup" strategy="weak" />
                <reference-many fieldName="hardGroup" strategy="hard" />
                <reference-many fieldName="pathGroup" strategy="path" />
            </document>
        </doctrine-mapping>

    .. code-block:: yaml

        MyPersistentClass:
            referenceOne:
                weakTarget:
                  strategy: weak
                hardTarget:
                  strategy: hard
                pathTarget:
                  strategy: path
            referenceMany:
                weakGroup:
                  strategy: weak
                hardGroup:
                  strategy: hard
                pathGroup:
                  strategy: path

ReferenceMany documents will always be handled as collection to allow for lazy loading,
regardless of the strategy chosen.

All types of reference support the optional argument ``targetDocument``.
This can be used to tell what the expected document type for the reference target is.
If you only reference documents of one specific type, you can use this as sanity check,
additionally path references will be faster this way.

If you do not set the targetDocument, you can reference documents of any type.
In ReferenceMany collections, you can even have documents of mixed types.


.. note::

    If your repository supports programmatically setting the uuid property at node creation,
    you can just persist your main document and the referenced documents will be persisted
    automatically.

    Otherwise you first need to flush the document manager for the reference targets before
    you can reference them in your document.


Referrers back to the referencing documents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PHPCR-ODM is able to tell which documents reference a specific document, if the `hard` or
`weak` strategy is used. The Referrers mapping provides a read only field with a collection
of all documents referencing this document.

In ORM terms, the Reference is the owning side of the association, while the Referrer is the inverse side.

You can use the ``filter`` attribute to limit the collection to a specific property name
on the referring side. The filter follows the ``name`` parameter of
`PHPCR\NodeInterface::getReferences() <http://phpcr.github.com/doc/html/phpcr/nodeinterface.html#getReferences%28%29>`_

Additionally you can filter for only weak or only hard references with ``referenceType`` -
if you don't you get both types of references.

.. configuration-block::

    .. code-block:: php

        /** @Referrers */
        private $allReferrers;
        /** @Referrers(filter="weakTarget") */
        private $specificReferrers;
        /** @Referrers(referenceType="hard") */
        private $hardReferrers;

    .. code-block:: xml

        <doctrine-mapping>
            <document class="MyPersistentClass">
                <referrers fieldName="allReferrers" />
                <referrers fieldName="specificReferrers" filter="weakTarget" />
                <referrers fieldName="hardReferrers" reference-type="hard" />
            </document>
        </doctrine-mapping>

    .. code-block:: yaml

        MyPersistentClass:
            referrers:
                allReferrers: ~
                specificReferrers:
                    filter: weakTarget
                hardReferrers:
                    referenceType: hard


.. _collections:

Collections
-----------

TODO: review

In all the examples of many-valued associations in this manual we
will make use of a ``Collection`` interface and a corresponding
default implementation ``ArrayCollection`` that are defined in the
``Doctrine\Common\Collections`` namespace. Why do we need that?
Doesn't that couple my domain model to Doctrine? Unfortunately, PHP
arrays, while being great for many things, do not make up for good
collections of business objects, especially not in the context of
an ORM. The reason is that plain PHP arrays can not be
transparently extended / instrumented in PHP code, which is
necessary for a lot of advanced ORM features. The classes /
interfaces that come closest to an OO collection are ArrayAccess
and ArrayObject but until instances of these types can be used in
all places where a plain array can be used (something that may
happen in PHP6) their usability is fairly limited. You "can"
type-hint on ``ArrayAccess`` instead of ``Collection``, since the
Collection interface extends ``ArrayAccess``, but this will
severely limit you in the way you can work with the collection,
because the ``ArrayAccess`` API is (intentionally) very primitive
and more importantly because you can not pass this collection to
all the useful PHP array functions, which makes it very hard to
work with.

.. warning::

    The Collection interface and ArrayCollection class,
    like everything else in the Doctrine namespace, are neither part of
    the ORM, nor the DBAL, it is a plain PHP class that has no outside
    dependencies apart from dependencies on PHP itself (and the SPL).
    Therefore using this class in your domain classes and elsewhere
    does not introduce a coupling to the persistence layer. The
    Collection class, like everything else in the Common namespace, is
    not part of the persistence layer. You could even copy that class
    over to your project if you want to remove Doctrine from your
    project and all your domain classes will work the same as before.



Initializing Collections
------------------------

You have to be careful when using entity fields that contain a
collection of related entities. Say we have a User entity that
contains a collection of groups:

.. code-block:: php

    <?php
    /** @Entity **/
    class User
    {
        /** @ManyToMany(targetEntity="Group") **/
        private $groups;

        public function getGroups()
        {
            return $this->groups;
        }
    }

With this code alone the ``$groups`` field only contains an
instance of ``Doctrine\Common\Collections\Collection`` if the user
is retrieved from Doctrine, however not after you instantiated a
fresh instance of the User. When your user entity is still new
``$groups`` will obviously be null.

This is why we recommend to initialize all collection fields to an
empty ``ArrayCollection`` in your entities constructor:

.. code-block:: php

    <?php
    use Doctrine\Common\Collections\ArrayCollection;

    /** @Entity **/
    class User
    {
        /** @ManyToMany(targetEntity="Group") **/
        private $groups;

        public function __construct()
        {
            $this->groups = new ArrayCollection();
        }

        public function getGroups()
        {
            return $this->groups;
        }
    }

Now the following code will be working even if the Entity hasn't
been associated with an EntityManager yet:

.. code-block:: php

    <?php
    $group = $entityManager->find('Group', $groupId);
    $user = new User();
    $user->getGroups()->add($group);
